; Library: LIBMISCX.ACT›; Author.: Wade Ripkowski›; Desc...: Misc Routines-XL/XE›; Date...: 2015.08›; License: GNU General Public License v3.0›; Revised: 2021.01-Add IKC2ATA›;                 -Add Wait›;          2022.07-Add WaitKCX››; Requires DEFINESX.ACT be loaded 1st!›››; --------------------------------------›; Func..: IKC2ATA(BYTE bN)›; Desc..: Converts internal key code›;         to atascii›; Params: bN = Internal code›; Return: ATASCII code for IKC<192›;         bN for IKC>191›;         199 for no mapping ›; Notes.: Does not change if IKC>191›; -------------------------------------- ›BYTE FUNC IKC2ATA(BYTE bN)›CHAR ARRAY cL(192)=[›  108 106  59 199 199 107  43  42 111 199›  112 117 155 105  45  61 118 199  99 199›  199  98 120 122  52 199  51  54 199  53›   50  49  44  32  46 110 199 109  47 199›  114 199 101 121 199 116 119 113  57 199›   48  55 199  56  60  62 102 104 100 199›  199 103 115  97  76  74  58 199 199  75›   92  94  79 199  80  85 199  73  95 124›   86 199  67 199 199  66  88  90  36 199›   35  38 199  37  34  33  91  32  93  78›  199  77  63 199  82 199  69  89 199  84›   87  81  40 199  41  39 199  64 199 199›   70  72  68 199 199  71  83  65  12  10›  123 199 199  11 199 199  15 199  16  21›  199   9 199 199  22 199   3 199 199   2›   24  26 199 199 199 199 199 199 199 199›  199 199  96  14 199  13 199 199  18 199›    5  25 199  20  23  17 199 199 199 199›  199 199 199 199   6   8   4 199 199   7›   19   1 ]›BYTE bR››; Get atascii from array if icode<192›if bN<192 then›  bR=cL(bN)›else›  ; Else dont change it›  bR=bN›fi››RETURN(bR)›››; -----------------------------------›; Proc..: Wait(BYTE bN)›; Param.: bN = Number of seconds›; Desc..: Waits bN seconds›; -----------------------------------›PROC Wait(BYTE bN)›BYTE RTCLK=20,bS››; Reset jiffy and second counters›RTCLK=0›bS=0›   ›; Loop until second counter hits bN›while bS<bN›DO›  ; If RTCLK >= 60. jiffy=1/60 second›  if RTCLK>=60 then›    ; Increment second counter, reset clock›    bS==+1›    RTCLK=0›  fi›OD››RETURN›››; --------------------------------------›; Func..: WaitYN(BYTE bE)›; Param.: bE=1 to print Y or N›; Return: BYTE (1=Y,0=N)›; Desc..: Waits for Y or N keypress›; --------------------------------------›BYTE FUNC WaitYN(BYTE bE)›  BYTE bRCH=764,bR=[0],bK=[0]››  DO›    ; Wait for any keypress›    WHILE bRCH=KNONE DO OD››    ; Key keypress and reset debounce›    bK=bRCH›    bRCH=KNONE›  ; Stay in loop until YyNn›  UNTIL bK=43 OR bK=107 OR›        bK=35 OR bK=99›  OD››  ; If Yy then set return 1›  if bK=43 OR bK=107 then›    bR=1›  fi››  ; If echo on›  if bE=1 then›    ; If Y, print Y›    if bR=1 then›      Put('Y)›    ; Else print N›    else›      Put('N)›    fi›  fi›RETURN(bR)›››; --------------------------------------›; Func..: WaitKCX(BYTE bI)›; Param.: bI=TRUE allow inverse toggle›; Return: CARD=keycode pressed›; Desc..: Waits for any key, help key,›;         or console key press.›; Notes.: XL/XE only›; --------------------------------------›CARD FUNC WaitKCX(BYTE bI)›  BYTE bRCH=764,bRCO=53279,bHLP=732,bINV=694,bCAP=702›  CARD cB=[0]›              ›  ; Wait for key›  WHILE bRCH=KNONE AND bRCO=KCNON AND bHLP=0›  DO OD ››  ; Process console key›  if bRCO#KCNON then›    cB=bRCO+256››  ; Process help key, must debounce›  elseif bHLP>0 then›    cB=KFHLP›    bHLP=0››  ; Toggle caps›  elseif bRCH=KCAP then›    cB=bRCH›    bCAP=bCAP!64››  ; Toggle inverse›  elseif bRCH=KINV then›    cB=bRCH›    ; Toggle if allowed›    if bI=TRUE then›      bINV=bINV!128›    fi››  ; All else›  else›    cB=bRCH›  fi››  ; Debounce key›  bRCH=KNONE›RETURN(cB)››MODULE››