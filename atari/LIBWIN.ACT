; Library: LIBWIN.ACT›; Desc...: Window Lirbary›; Author.: Wade Ripkowski›; Date...: 2016.04›; License: GNU General Public License v3.0›; Note...: Requires DEFWIN.ACT first!›; Revised: 2021.01.06-Fix pointers (CHAR)›;                    -Fix StrInv calls›;          2021.01.20-Fix WPrint buffer size›;          2021.02.01-Add WDiv›;                     Add WPCENT to WOrn››MODULE››; --------------------------------------›; Proc..: WInit()›; Desc..: Initializes windowing system.›; --------------------------------------›PROC WInit()›  BYTE bL››  ; Setup cursor and screen›  Poke(752,1)›  Poke(82,0)›  Position(0,0)›  Put($7D)››  ; Clear window memory›  Zero(baWM,WBUFSZ)››  ; Set index into window memory›  cpWM=baWM››  ; Work on 10 window+system handles›  for bL=0 to 10›  DO›    ; Find windows handle location›    pWn=baW+(WRECSZ*bL)››    ; Clear handle record vars›    pWn.bS=WOFF›    pWn.bX=0›    pWn.bY=0›    pWn.bW=0›    pWn.bH=0›    pWn.bI=WOFF›    pWn.cM=baWM  ; point at base storage›    pWn.cZ=0›  OD››  ; Set virtual cursor coords›  vCur.vX=0›  vCur.vY=0›RETURN›››; --------------------------------------›; Proc..: WBack(BYTE bN)›; Desc..: Set screen background›; Param.: bN = background char (internal)›; Notes.: WBNONE for empty backgound›; --------------------------------------›PROC WBack(BYTE bN)›  ; Set background›  SetBlock(RSCRN,960,bN)›RETURN›››; --------------------------------------›; Func..: BYTE WOpen(BYTE x,y,w,h,bT)›; Desc..: Opens new window›; Params: x = column›;         y = row›;         w = width›;         h = height›;         bT = display in inverse›;              WINVON/WINVOFF›; Return: Window handle number›;         >100 on error›; Notes.: cL is manipulated as byte store,›;         not a string. (0) is data not size.›; --------------------------------------›BYTE FUNC WOpen(BYTE x,y,w,h,bT)›  BYTE bR,bL,bD,bC›  CHAR ARRAY cL(40)›  CHAR POINTER pS››  ; Set default return code›  bR=WENONE››  ; Cycle through handles (excl system)›  for bL=0 to 9›  DO›    ; Find window handle record›    pWn=baW+(WRECSZ*bL)››    ; If handle record not in use›    if pWn.bS=WOFF then›      ; Set handle record in use›      pWn.bS=WON››      ; Set storage address and size›      pWn.cM=cpWM›      pWn.cZ=w*h››      ; Set other handle record vars›      pWn.bX=x›      pWn.bY=y›      pWn.bW=w›      pWn.bH=h›      pWn.bI=bT››      ; Find top left corner of window›      ; in screen memory›      pS=RSCRN+(y*40)+x››      ; Draw window›      for bD=0 to h-1›      DO›        ; Build window line as string›        ; (internal char codes)›        ; Top or bottom line "+-+"›        if bD=0 or bD=h-1 then›          ; Set solid line -›          SetBlock(cL,w,82)››          ; Top line corners›          if bD=0 then›            cL(0)=81›            cL(w-1)=69›          ; Bottom line corners›          else›            cL(0)=90›            cL(w-1)=67›          fi›        ; Middle line "| |"›        else›          ; Set space and sides›          SetBlock(cL,w,0)›          cL(0)=124›          cL(w-1)=124›        fi››        ; If inverse flag, flip line›        if bT=WON then›          for bC=0 to w-1›          DO›            cL(bC)==!128›          OD›        fi››        ; Save underlying scrn to win mem›        MoveBlock(cpWM,pS,w)›        ; Inc mem ptr index by width›        cpWM==+w›        ; Move line to screen›        MoveBlock(pS,cL,w)›        ; Inc scr by 40 to next line start›        pS==+40›      OD››      ; Set return to handle number›      bR=bL››      ; Exit loop›      EXIT›    fi›  OD›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WClose(BYTE bN)›; Desc..: Closes a window›; Params: bN = number of window handle›; Return: 0 if success›;         >100 on error›; --------------------------------------›BYTE FUNC WClose(BYTE bN)›  BYTE bR,bL›  CHAR POINTER pS,pA››  ; Set default return code›  bR=WENOPN››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS#WOFF then›    ; Find top left corner of window›    ; in screen memory›    pS=RSCRN+(pWn.bY*40)+pWn.bX››    ; Set temp ptr to start of win mem›    pA=pWn.cM››    ; Restore screen line by line›    for bL=0 to pWn.bH-1›    DO›      ; Restore underlying scrn from win mem›      MoveBlock(pS,pA,pWn.bW)›      ; Inc mem ptr index by width›      pA==+pWn.bW›      ; Inc scr by 40 to next line start›      pS==+40›    OD››    ; Clear window memory›    Zero(pWn.cM,pWn.cZ)››    ; Set win mem ptr to prev location›    cpWM==-pWn.cZ››    ; Clear handle›    pWn.bS=WOFF›    pWn.bX=0›    pWn.bY=0›    pWn.bW=0›    pWn.bH=0›    pWn.bI=WOFF›    pWn.cM=baWM  ; point at base storage›    pWn.cZ=0››    ; Set return›    bR=0›  fi›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WStat(BYTE bN)›; Desc..: Tests if window handle is open›; Params: bN = number of window handle›; Return: WSUSED (in use) or›;         WSFREE (not used)›; --------------------------------------›BYTE FUNC WStat(BYTE bN)›  ; Find window handle record›  pWn=baW+(WRECSZ*bN)›RETURN(pWn.bS)›››; --------------------------------------›; Func..: BYTE WPos(BYTE bN,x,y)›; Desc..: Moves cursor to x,y in window›;         or x,y of screen›; Params: bN = number of window handle›;             or WPABS for screen›;         x = column for cursor›;         y = row for cursor›; Return: WSUSED (in use) or›;         WSFREE (not used)›; Revisd: 2021.01-Add position move›; --------------------------------------›BYTE FUNC WPos(BYTE bN,x,y)›  BYTE bR››  ; Set valid return›  bR=0››  ; If absolute mode›  if bN=WPABS then›    ; Set screen coords›    vCur.vX=x›    vCur.vY=y›  else›    ; Find window handle record›    pWn=baW+(WRECSZ*bN)››    ; Only if handle in use›    if pWn.bS#WOFF then›      ; Set relative to window›      vCur.vX=pWn.bX+x›      vCur.vY=pWn.bY+y›    else›      ; Set not open return code›      bR=WENOPN›    fi›  fi                       ››  ; Move actual cursor›  Position(vCur.vX,vCur.vY)›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WPut(BYTE bN,x)›; Desc..: Puts byte x in window›;         at virtual cursor coord›; Params: bN = number of window handle›;         x = ATA byte to display›; Return: WSUSED (in use) or›;         WSFREE (not used)›; --------------------------------------›BYTE FUNC WPut(BYTE bN,x)›  BYTE bR›  CHAR ARRAY bC(2)›  CHAR POINTER pS››  ; Set default return›  bR=WENOPN››  ; Convert passed byte into string›  bC(0)=1›  bC(1)=x››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS#WOFF then›    ; Convert byte from ATA to INT›    StrAI(bC)››    ; If window is inverse, flip byte›    if pWn.bI=WON then›      bC(1)==!128›    fi››    ; Find screen loc based on vCur›    pS=RSCRN+(vCur.vY*40)+vCur.vX››    ; Move byte to screen›    ; pS^=bC(1)›    MoveBlock(pS,bC+1,1)››    ; Inc virtual cur by 1›    vCur.vX==+1››    ; Set return code›    bR=0›  fi›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WOrn(BYTE bN,bT,bL CHAR POINTER pS)›; Desc..: Add ornament decor to window›; Params: bN = Number of window handle›;         bT = Top or bottom (WPTOP/WPBOT)›;         bL = Position (WPLEFT/WPRIGHT/WPCENT)›;         pS = Display string pointer›; Return: 0 if success›;         >100 on error›; Notes.: Max 36 for frame and bookends›; --------------------------------------›BYTE FUNC WOrn(BYTE bN,bT,bL CHAR POINTER pS)›  BYTE bR›  CHAR ARRAY cL(36)›  CHAR POINTER cS››  ; Set default return code›  bR=WENOPN››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS=WON then›    ; Create footer string›    ; Copy string›    SCopy(cL+1,pS)›    ; Set open bookend›    cL(1)=4›    ; Set close bookend›    cL(pS(0)+2)=1›    ; Set string len to include bookends›    cL(0)=pS(0)+2››    ; Convert from ATA to INT›    StrAI(cL)››    ; If inverse on, inverse all›    if pWn.bI=WON then›      StrInv(cL,cL(0))›    ; Else inverse off, inverse only text›    else›      ; Skip first 1b (bookend)›      ; Skip last 1b (bookend)›      StrInv(cL+1,cL(0)-2)›    fi››    ; Find base location of window›    cS=RSCRN+(pWn.bY*40)››    ; If bottom find lower location›    if bT=WPBOT then›      cS==+((pWn.bH-1)*40)›    fi››    ; If left, add 1 (corner)›    if bL=WPLFT then›      cS==+pWn.bX+1››    ; If right, add x + width - length - 3›    elseif bL=WPRGT then›      cS==+pWn.bX+pWn.bW-pS(0)-3››    ; Else center›    else›      cS==+pWn.bX+((pWn.bW-cL(0))/2)›    fi››    ; Move title to screen›    MoveBlock(cS,cL+1,cL(0))››    ; Set valid return›    bR=0›  fi›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WTitle(BYTE bN›;                     CHAR POINTER pS)›; Desc..: Add title decor to window›; Params: bN = number of window handle›;         pS = Title string pointer›; Return: 0 if success›;         >100 on error        ›; Notes.: Max 36 for frame and bookends›;         2021.01-Deprecated: Use WOrn›; --------------------------------------›BYTE FUNC WTitle(BYTE bN CHAR POINTER pS)›RETURN(WOrn(bN,WPTOP,WPLFT,pS))›››; --------------------------------------›; Func..: BYTE WPrint(BYTE bN,x,y›;                     CHAR POINTER pS)›; Desc..: Print text in window at pos›; Params: bN = number of window handle›;         x = column to print at›;         y = row to print at›;         pS = Text string pointer›; Notes.: Prints max 38 chars for frame›;         Accepts max of 128 chars›; Return: 0 if success›;         >100 on error›; --------------------------------------›BYTE FUNC WPrint(BYTE bN,x,y CHAR POINTER pS)›  BYTE bR›  CHAR ARRAY cL(129)›  CHAR POINTER cS››  ; Set default return code›  bR=WENOPN››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS#WOFF then›    ; Copy string to line buffer›    SCopy(cL,pS)››    ; Ensure text wont overrun›    ; Check len not > width-x-1›    ; x is column offset›    ; width inc frames, remove 1›    ; instead of 2 due to x as 1 based›    if cL(0) > pWn.bW-x-1 then›      cL(0)=pWn.bW-x-1›    fi››    ; Convert from ATA to INT›    StrAI(cL)››    ; Make inverse if ON›    if pWn.bI=WON then›      ; Always inverse title text›      StrInv(cL,cL(0))›    fi››    ; Find top left corner of window›    ; in screen memory (inside frame)›    cS=RSCRN+(pWn.bY*40)+pWn.bX››    ; Add 40 for each row (Y)›    cS==+(y*40)››    ; If not center, move to pos›    if x#WPCNT then›      ; Add x for column›      cS==+x››    ; Else move to centered position›    else›      ; Add width-length/2 for centered x.›      cS==+((pWn.bW-cL(0))/2)›    fi››    ; Move it to screen, skip len byte›    MoveBlock(cS,cL+1,cL(0))››    ; Set valid return›    bR=0›  fi›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WClr(BYTE bN)›; Desc..: Clears window contents›; Params: bN = number of window handle›; Return: 0 if success›;         >100 on error›; --------------------------------------›BYTE FUNC WClr(BYTE bN)›  BYTE bR,bL›  CHAR ARRAY cL(38)›  CHAR POINTER cS››  ; Set default return code›  bR=WENOPN››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS=WON then›    ; Find top left corner of window›    ; in screen memory (inside frame)›    cS=RSCRN+(pWn.bY*40)+pWn.bX+41››    ; Make line empty›    SetBlock(cL,pWn.bW-2,0)››    ; If inverse flip line›    if pWn.bI=WON then›      StrInv(cL,pWn.bW-2)›    fi››    ; Clear window line by line›    for bL=1 to pWn.bH-2›    DO›      ; Restore underlying scrn from win mem›      MoveBlock(cS,cL,pWn.bW-2)›      ; Inc scr by 40 to next line start›      cS==+40›    OD››    ; Set return›    bR=0›  fi›RETURN(bR)›››; --------------------------------------›; Func..: BYTE WDiv(BYTE bN,y,bD)›; Desc..: Add or remove divider›; Params: bN = Number of window handle›;         y = Which row for divider›;         bD = Display On/Off indicator›; Return: 0 if success›;         >100 on error›; --------------------------------------›BYTE FUNC WDiv(BYTE bN,y,bD)›  BYTE bR,bE›  CHAR ARRAY cL(40)›  CHAR POINTER cS››  ; Set default return code›  bR=WENOPN››  ; Find window handle record›  pWn=baW+(WRECSZ*bN)››  ; Only if handle in use›  if pWn.bS=WON then›    ; Get window width›    bE=pWn.bW››    ; Create divider string››    ; If turning on, set ornaments›    if bD=WON then›      ; Set solid line›      SetBlock(cL,bE,82)›      ; Set left ›      cL(1)=65›      ; Set right›      cL(bE)=68›    else›      ; Set blank line›      SetBlock(cL,bE,0)›      ; Set left ›      cL(1)=124›      ; Set right›      cL(bE)=124›    fi››    ; Set string len to width of window›    cL(0)=bE››    ; If inverse on, inverse all›    if pWn.bI=WON then›      StrInv(cL,cL(0))›    fi››    ; Find base location of window›    cS=RSCRN+((pWn.bY+y)*40)+pWn.bX››    ; Move to screen›    MoveBlock(cS,cL+1,cL(0))››    ; Set valid return›    bR=0›  fi›RETURN(bR)››