; Library: LIBGADG.ACT›; Author.: Wade Ripkowski›; Desc...: Gadget Routines-400/800›; Date...: 2016.04›; License: GNU General Public License v3.0›; Revised: 2021.01.05 Add -= to MenuV nav›;          2021.01.16 Add GAlert,GInput›;          2021.01.27 Add GRadio›;          2021.01.28 Add GCheck›;          2022.07.17 Add GSpin››; Requires DEFINES.ACT be loaded 1st!›; Requires LIBSTR.ACT be loaded 1st!›; Requires LIBWIN.ACT be loaded 1st!›››; --------------------------------------›; Func..: GCheck(byte bN,x,y,bI,bD)›; Desc..: Displays check box and gets choice›; Params: bN = Window handle number›;         x = Column of window to place check›;         y = Row of window›;         bI = Display only indicator›;         bD = Default (initial value)›; Req...: LIBWIN.ACT›;         LIBSTR.ACT›; -------------------------------------- ›BYTE FUNC GCheck(BYTE bN,x,y,bI,bD)›BYTE bR,bK,bC››; Set return and current value to default passed›bR=bD›bC=bD››; Loop until exit›DO›  ; If current then add pointer, else space›  if bC=GCON then›    WPrint(bN,x,y,"[Ø]")›  else›    WPrint(bN,x,y,"[ ]")›  fi››  ; If display only, just exit›  if bI=GDISP then›    exit›  else›    ; Get a keystroke›    bK=WaitKC()››    ; Process keystroke›    if bK=KESC then›      bR=XESC›      exit››    elseif bK=KTAB then›      bR=XTAB›      exit››    elseif bK=KSPACE or bK=KX or bK=KX_S then›      ; Toggle value›      if bC=GCON then›        bC=GCOFF›      else›        bC=GCON›      fi››      bR=bC›      exit››    elseif bK=KENTER then›      ; Set return current check value›      bR=bC›      exit›    fi›  fi›OD››; If current and return are same›if bR=bC then›  ; Show exit value›  if bR=GCON then›    WPrint(bN,x,y,"[X]")›  else                  ›    WPrint(bN,x,y,"[ ]")›  fi›else›  ; Show default value (no change)›  if bD=GCON then›    WPrint(bN,x,y,"[X]")›  else›    WPrint(bN,x,y,"[ ]")›  fi›fi››RETURN(bR)›››; --------------------------------------›; Func..: GRadio(byte bN,x,y,bD,bE,bI,bS CARD POINTER pA)›; Desc..: Displays radio buttons and gets choice›; Params: bN = Window handle number›;         x = Column of window to place buttons›;         y = Row of window›;         bD = direction of button placement›;         bE = Edit or display indicator›;              0 to display and exit›;         bI = Initial selected button›;         bS = Number of buttons›;         pA = Ragged array pointer›; Req...: LIBWIN.ACT›;         LIBSTR.ACT›; -------------------------------------- ›BYTE FUNC GRadio(BYTE bN,x,y,bD,bE,bI,bS CARD POINTER pA)›BYTE bR,bL,bK,bC,xp,yp›CHAR POINTER pS››; Set return and current button to default passed›bR=bI›bC=bI››; Loop until exit›DO›  ; Set drawing position offsets›  xp=0›  yp=0››  ; Display buttons›  for bL=1 to bS›  DO›    ; If current then add pointer, else space›    if bL=bC and bE#GDISP then›      WPos(bN,x+xp,y+yp)›      WPut(bN,CRGT_I)›    else›      WPrint(bN,x+xp,y+yp," ")›    fi››    ; If selected then add fill, else unfilled›    if bL=bR then›      WPrint(bN,x+xp+1,y+yp,"")›    else›      WPrint(bN,x+xp+1,y+yp,"o")›    fi››    ; Display button name itself›    WPrint(bN,x+xp+3,y+yp,pA(bL-1))››    ; Compute button position›    if bD=GHORZ then›      pS=pA(bL-1)›      ; Increase X display position›      xp==+(pS(0)+4)›    else›      ; Increase Y display position›      yp==+1›    fi        ›  OD››  ; If initial item is 0, just exit›  if bE=GDISP then›    exit›  else›    ; Get a keystroke›    bK=WaitKC()››    ; Process keystroke›    if bK=KLEFT or bK=KPLUS or bK=KUP or bK=KMINUS then›      bC==-1›      if bC<1 then bC=bS fi››    elseif bK=KRIGHT or bK=KASTER or bK=KDOWN or bK=KEQUAL then›      bC==+1›      if bC>bS then bC=1 fi››    elseif bK=KESC then›      bR=XESC›      exit››    elseif bK=KTAB then›      bR=XTAB›      exit››    elseif bK=KSPACE then›      bR=bC››    elseif bK=KENTER then›      bR=bC›      exit›    fi›  fi›OD››RETURN(bR)›››; --------------------------------------›; Func..: GButton(byte bN,x,y,bD,bS CARD POINTER pA)›; Desc..: Displays buttons and gets choice›; Params: bN = Window handle number›;         x = Column of window to place buttons›;         y = Row of window›;         bD = Initial selected button›;              0 to display and exit›;         bS = Number of buttons›;         pA = Ragged array pointer›; Note..: Button ornaments should be defined›;         in strings.›; Req...: LIBWIN.ACT›;         LIBSTR.ACT›; -------------------------------------- ›BYTE FUNC GButton(BYTE bN,x,y,bD,bS CARD POINTER pA)›BYTE bR,bL,bK,bP›CHAR POINTER pS›CHAR ARRAY cL(39)››; Set default button to start›bR=bD››; Loop until exit›DO›  ; Set drawing position offset›  bP=0››  ; Display buttons›  for bL=1 to bS›  DO›    ; Set string pointer to current array element addr›    pS=pA(bL-1)›   ›    ; Copy button to buffer and restore string›    SCopy(cL,pS)››    ; If this is the selected item, inverse it›    if bR=bL then›      StrInv(cL,cL(0))›    fi››    ; Display button›    WPrint(bN,x+bP,y,cL)›            ›    ; Increase display position›    bP==+pS(0)›  OD››  ; If display item is 0, just exit›  if bD=GDISP then›    exit›  else›    ; Get a keystroke›    bK=WaitKC()››    ; Process keystroke›    if bK=KLEFT or bK=KPLUS or bK=KUP or bK=KMINUS then›      bR==-1›      if bR<1 then bR=bS fi››    elseif bK=KRIGHT or bK=KASTER or bK=KDOWN or bK=KEQUAL then›      bR==+1›      if bR>bS then bR=1 fi››    elseif bK=KESC then›      bR=XESC›      exit››    elseif bK=KTAB then›      bR=XTAB›      exit››    elseif bK=KENTER then›      exit›    fi›  fi›OD››RETURN(bR)›››; --------------------------------------›; Proc..: GAlert(CHAR POINTER pS)›; Desc..: Displays centered alert on screen›; Params: pS = Message string›;              38 characters max›; -------------------------------------- ›PROC GAlert(CHAR POINTER pS)›BYTE bT,x››; Find left window position›x=((38-pS(0))/2)››; Show window›bT=WOpen(x, 9, pS(0)+2, 4, WOFF)›WTitle(bT, "Alert")›WPrint(bT, WPCNT, 1, pS) ›WPrint(bT, WPCNT, 2," ÏË ")››; Wait for key›WaitKC()››; Close window›WClose(bT)››RETURN›››; --------------------------------------›; Proc..: GProg(BYTE bN,x,y,bS)›; Desc..: Displays progress bar›; Params: bN = number of window handle›;         x = column for cursor›;         y = row for cursor›;         bS = bar size (pct complete)›; --------------------------------------›PROC GProg(BYTE bN,x,y,bS)›  INT bL›  CHAR ARRAY cL(21),cB(21)››  ; Set default and block lines›  SCopy(cL,"                    ")››  ; Update bar contents›  ; Div by 5 since bar is 1/5 100›  for bL=1 to bS/5›  DO›    cL(bL)=CINVSP›  OD››  ; Display new bar›  WPrint(bN,x,y,cL)›RETURN›››; --------------------------------------›; Func..: GInput(byte bN,x,y,bT,bS CHAR POINTER pS)›; Desc..: Gets string›; Params: bN = Window handle number›;         x = Column of window to start get›;         y = Row of window›;         bT = Allowed character type›;         bS = Display size for string (max 40)›;         pS = String pointer›; Req...: LIBWIN.ACT›;         LIBSTR.ACT›; -------------------------------------- ›BYTE FUNC GInput(BYTE bN,x,y,bT,bS CHAR POINTER pS)›CHAR ARRAY cD(41),cE(128)›BYTE bR,bD,bE,bK,bC,bL,bP››; Set default return›bR=FALSE››; Set start display and edit positions›bD=1›bE=1››; Copy original string to edit buffer›SCopy(cE,pS)››; Repeat until ESC or RETURN›DO›  ; Copy display string from edit buffer›  SCopyS(cD,cE,bD,bD+bS-1)››  ; Inverse the display string›  StrInv(cD,bS)››  ; Un-inverse the cursor char›  cD(bE-bD+1)==!128  ››  ; Show display string›  WPrint(bN, x, y, cD)››  ; Wait for a keystroke›  bK=WaitKC()››  ; Get ATASCII version of keystroke›  bC=IKC2ATA(bK)››  ; Is keystroke version RIGHT?›  ; Move edit position›  if bK=KRIGHT then›    bE==+1››  ; Is keystroke version LEFT?›  ; Move edit position›  elseif bK=KLEFT then›    bE==-1››  ; Is keystroke version Ctrl-Shft-S?›  ; Go beginning›  elseif bK=KS_CS then›    bE=1››  ; Is keystroke version Ctrl-Shft-E?›  ; Go end›  elseif bK=KE_CS then›    bE=pS(0)››  ; Is keystroke version DEL?›  ; Set char to space, move position›  elseif bK=KDEL then›    ; Move edit and display positions if >1›    if bE>1 then›      bE==-1›    fi›    cE(bE)=32››  ; Is keystroke version DEL_S?›  ; Clear line (contents)›  elseif bK=KDEL_S then›    ; Edit buffer address+1, skip len byte›    SetBlock(cE+1,pS(0),32)››  ; Is keystroke version DEL_C?›  ; Right delete›  elseif bK=KDEL_C then›    ; Copy each char to the char before›    for bL=bE+1 to pS(0)›    DO›      cE(bL-1)=cE(bL)›    OD››    ; Set last char to space›    bL=pS(0)›    cE(bL)=32››  ; Is keystroke version INS?›  ; Right insert›  elseif bK=KINS then›    ; Only insert if not at end›    if bE<pS(0) then›      ; Copy each char to next position›      ; Work from end to edit position›      bL=pS(0)›      DO›        cE(bL)=cE(bL-1)›        bL==-1›      UNTIL bL=bE›      OD››      ; Put space in current position›      cE(bE)=32›    fi››  ; Is keystroke version ENTER?›  ; Copy edit buffer to original string, exit›  elseif bK=KENTER then›    SCopy(pS,cE)›    bR=TRUE›    exit››  ; Is keystroke version ESC?›  ; Restore original string to edit buffer, exit›  elseif bK=KESC then›    SCopy(cE,pS)›    bR=XESC›    exit››  ; Is keystroke version TAB?›  ; Restore original string to edit buffer, exit›  elseif bK=KTAB then›    SCopy(cE,pS)›    bR=XTAB›    exit››  ; Is ATASCII code a printing character?›  ; 0 (heart) not possible›  elseif bC>=1 and bC<=191 then›    ; Set add flag to false›    bP=FALSE››    ; Apply type restrictions›    ; For ANY, allow all but cursor keys›    if bT=GANY and (bC<=28 or bC>=32) then›      bP=TRUE››    ; For ALNUM, allow _ 0-9 A-Z a-z›    elseif bT=GALNUM then›      if bC=32 or (bC>=48 and bC<=57) or (bC>=65 and bC<=90) or (bC>=97 and bC<=122) then›        bP=TRUE›      fi ››    ; For ALPHA, allow _ A-Z a-z›    elseif bT=GALPHA then›      if bC=32 or (bC>=65 and bC<=90) or (bC>=97 and bC<=122) then›        bP=TRUE›      fi››    ; For NUMBER, allow . - 0-9›    elseif bT=GNUMER then›      if bC=45 or bC=46 or (bC>=48 and bC<=57) then›        bP=TRUE›      fi›    fi››    ; Replace char in edit buffer at edit position›    if bP=TRUE then›      cE(bE)=bC›      bE==+1  ›    fi›  fi››  ; Check edit & display position extents››  ; If edit > max len, set =›  if bE > pS(0) then›    bE=pS(0)››  ; Or if < 1, set to 1›  elseif bE < 1 then›    bE=1›  fi››  ; If edit >= display size then display = edit-size›  if bE >= bS then›    bD=bE-bS+1››  ; If edit < display size then display = 1›  elseif bE < bS then›    bD=1›  fi›OD››; Get display string and print›SCopyS(cD,cE,1,bS)›WPrint(bN,x,y,cD)››RETURN(bR)›››; --------------------------------------›; Func..: GSpin(BYTE bN,x,y,bL,bM,bP)›; Desc..: Displays value and spin 0 to 100›; Params: bN = Window handle number›;         x = Column of window to place spinner›;         y = Row of window›;         bL = Lowest value›;         bM = Max value›;         bP = initial value›; Req...: LIBWIN.ACT›;         LIBSTR.ACT›; --------------------------------------›BYTE FUNC GSpin(BYTE bN,x,y,bL,bM,bP)›BYTE bD,bK,bR›CHAR ARRAY cL(4)››; Set working value›bD=bP››; Loop until exit›DO›  ; Convert to string & inverse›  StrB(bD,cL)›  StrPad(cL,32,3)›  StrInv(cL,cL(0))››  ; Print value at spot›  WPrint(bN,x,y,cL)››  ; Get key›  bK=WaitKC()››  ; Process keystroke›  if bK=KLEFT or bK=KPLUS or bK=KDOWN or bK=KEQUAL then›    bD==-1›    if bD<bL then bD=bL fi››  elseif bK=KRIGHT or bK=KASTER or bK=KUP or bK=KMINUS then›    bD==+1›    if bD>bM then bD=bM fi››  elseif bK=KESC then›    bR=XESC ››    ; Convert to string›    StrB(bP,cL)››    exit››  elseif bK=KTAB then›    bR=XTAB››    ; Convert to string›    StrB(bP,cL)››    exit››  elseif bK=KENTER then›    ; Set return value›    bR=bD››    ; Convert to string›    StrB(bD,cL)››    exit›  fi›OD››; Redisplay value›StrPad(cL,32,3)›WPrint(bN,x,y,cL)››RETURN(bR)›››MODULE››