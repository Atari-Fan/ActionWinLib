; Library: LIBSTR.ACT›; Author.: Wade Ripkowski›; Date...: 2015.08›; Desc...: String Routines›; License: GNU General Public License v3.0›; Revised: 2021.01-Fix StrInv offset›;                  Fix StrAI group 3›››; --------------------------------------›; Func..: StrInv(CHAR POINTER pS BYTE bS)›; Param.: pS=String to convert›;         bS=Size of string›; Desc..: Inverses (video) a string       ›; --------------------------------------›PROC StrInv(CHAR POINTER pS BYTE bS)›  BYTE bL››  ; Process each element›  for bL=1 to bS ›  DO›    ; Add 128 to the value for inverse›    pS(bL)==!128›  OD›RETURN›››; --------------------------------------›; Func..: StrAI(CHAR POINTER pS)›; Param.: pS=String to convert›; Desc..: Converts ATASCII code to›;         internal code      ›; Revise: 2021.01-Fix group 3 from 154 to 159›; --------------------------------------›PROC StrAI(CHAR POINTER pS)›  BYTE bL››  ; Process each element›  for bL=1 to pS(0)›  DO›    if pS(bL)>=0 AND pS(bL)<=31 then›      pS(bL)==+64›    elseif pS(bL)>=32 AND pS(bL)<=95 then›      pS(bL)==-32›    elseif pS(bL)>=128 AND pS(bL)<=159 then›      pS(bL)==+64›    elseif pS(bL)>=160 AND pS(bL)<=223 then›      pS(bL)==-32›    fi›  OD›RETURN›››; --------------------------------------›; Func..: StrIA(CHAR POINTER pS)›; Param.: pS=String to convert›; Desc..: Converts internal code to›;         ATASCII code›; --------------------------------------›PROC StrIA(CHAR POINTER pS)›  BYTE bL››  ; Process each element›  for bL=1 to pS(0)›  DO›    if pS(bL)>=0 AND pS(bL)<=63 then›      pS(bL)==+32›    elseif pS(bL)>=64 AND pS(bL)<=95 then›      pS(bL)==-64›    elseif pS(bL)>=128 AND pS(bL)<=154 then›      pS(bL)==+32›    elseif pS(bL)>=160 AND pS(bL)<=191 then›      pS(bL)==+32›    elseif pS(bL)>=192 AND pS(bL)<=223 then›      pS(bL)==-64›    fi›  OD›RETURN›››; --------------------------------------›; Func..: SubStr(CHAR ARRAY cB,cE BYTE bN,bS)›; Param.: cB=From String›;         cE=To String›;         bN=Start Position›;         bS=Number of Chars to copy›; Desc..: Get sub-string of string›; --------------------------------------›PROC SubStr(CHAR ARRAY cB,cE BYTE bN,bS)›  BYTE bL=[0]››  FOR bL=1 to bS›  DO›    cE(bL)=cB(((bN-1)*bS)+bL)›  OD››  cE(0)=bS›RETURN›››; --------------------------------------›; Proc..: StrPad(CHAR POINTER ps CHAR bc BYTE bL)›; Param.: pS=Pointer to string to pad›;         bC=Character to pad with›;         bL=Length to pad to›; Desc..: Left pads a string with a char›; Notes.: Max of 10 in length.›; --------------------------------------›PROC StrPad(CHAR POINTER pS CHAR bC BYTE bL)›CHAR ARRAY pA="          "››; Fill the temp string with char›SetBlock(pA+1,10,bC)››; Copy inc string into temp string›SAssign(pA,pS,bL-pS(0)+1,bL)››; Copy padded temp string to inc string›SCopy(pS,pA)››; Set inc string pointer to new length›pS(0)=bL››RETURN›››; --------------------------------------›; Proc..: StrTrim(CHAR POINTER ps)›; Param.: pS=Pointer to string to trim›; Desc..: Trims space from string end›; --------------------------------------›PROC StrTrim(CHAR POINTER pS)›BYTE bL,bC››; Set counter to end of string›bL=pS(0)››; Loop from string end to start›while bL>=1›DO        ›  ; If char is space, set len to curr-1 ›  if pS(bL)=32 then›    bC=bL-1›  else›    exit›  fi››  bL==-1›OD››; Set string pointer length to new value›pS(0)=bC››RETURN›››MODULE›››